-- ============================================
-- FARMACIA PC - DATABASE SCHEMA
-- Sistema de Inventario con Lógica FEFO
-- ============================================

-- 1. TABLA DE CATEGORÍAS
-- Clasificación de medicamentos (Jarabes, Tabletas, Inyectables, etc.)
CREATE TABLE IF NOT EXISTS categorias (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre TEXT NOT NULL UNIQUE,
    descripcion TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 2. TABLA MAESTRA DE MEDICAMENTOS
-- Catálogo principal de productos
CREATE TABLE IF NOT EXISTS medicamentos (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    nombre TEXT NOT NULL,
    descripcion TEXT,
    principio_activo TEXT,
    laboratorio TEXT,
    categoria_id BIGINT REFERENCES categorias(id) ON DELETE SET NULL,
    stock_minimo INT DEFAULT 5, -- Alerta cuando el stock total baje de este número
    activo BOOLEAN DEFAULT TRUE, -- Para soft delete
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. TABLA DE LOTES (CORAZÓN DEL SISTEMA FEFO)
-- Un medicamento puede tener múltiples lotes con diferentes fechas de vencimiento
CREATE TABLE IF NOT EXISTS lotes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    medicamento_id UUID REFERENCES medicamentos(id) ON DELETE CASCADE NOT NULL,
    codigo_lote TEXT NOT NULL, -- Código impreso en la caja
    fecha_vencimiento DATE NOT NULL,
    stock_actual INT DEFAULT 0 CHECK (stock_actual >= 0),
    costo_compra DECIMAL(10,2),
    precio_venta DECIMAL(10,2),
    activo BOOLEAN DEFAULT TRUE, -- Se desactiva automáticamente cuando stock = 0
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(medicamento_id, codigo_lote) -- No duplicar lotes para el mismo medicamento
);

-- 4. TABLA DE MOVIMIENTOS (AUDITORÍA COMPLETA)
-- Registra todas las entradas, salidas y ajustes de inventario
CREATE TABLE IF NOT EXISTS movimientos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    lote_id UUID REFERENCES lotes(id) ON DELETE SET NULL,
    medicamento_id UUID REFERENCES medicamentos(id) ON DELETE SET NULL,
    tipo_movimiento TEXT CHECK (tipo_movimiento IN ('ENTRADA', 'VENTA', 'AJUSTE', 'MERMA_VENCIMIENTO')) NOT NULL,
    cantidad INT NOT NULL, -- Positivo para entradas, negativo para salidas
    precio_unitario DECIMAL(10,2),
    total DECIMAL(10,2),
    observaciones TEXT,
    usuario_id UUID, -- Conecta con auth.users de Supabase (opcional)
    fecha TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================
-- ÍNDICES PARA OPTIMIZACIÓN
-- ============================================



-- Búsqueda por nombre (autocompletado)
CREATE INDEX IF NOT EXISTS idx_medicamentos_nombre ON medicamentos(nombre);

-- Filtrado por categoría
CREATE INDEX IF NOT EXISTS idx_medicamentos_categoria ON medicamentos(categoria_id);

-- FEFO: Ordenar lotes por fecha de vencimiento
CREATE INDEX IF NOT EXISTS idx_lotes_fecha_vencimiento ON lotes(fecha_vencimiento);

-- Lotes activos de un medicamento
CREATE INDEX IF NOT EXISTS idx_lotes_medicamento_activo ON lotes(medicamento_id, activo);

-- Auditoría: Movimientos por fecha
CREATE INDEX IF NOT EXISTS idx_movimientos_fecha ON movimientos(fecha DESC);

-- Auditoría: Movimientos por tipo
CREATE INDEX IF NOT EXISTS idx_movimientos_tipo ON movimientos(tipo_movimiento);

-- ============================================
-- TRIGGERS AUTOMÁTICOS
-- ============================================

-- Trigger: Actualizar updated_at en medicamentos
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_medicamentos_updated_at
    BEFORE UPDATE ON medicamentos
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Trigger: Actualizar updated_at en lotes
CREATE TRIGGER update_lotes_updated_at
    BEFORE UPDATE ON lotes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Trigger: Desactivar lote cuando stock llega a 0
CREATE OR REPLACE FUNCTION desactivar_lote_sin_stock()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.stock_actual = 0 THEN
        NEW.activo = FALSE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_desactivar_lote_sin_stock
    BEFORE UPDATE ON lotes
    FOR EACH ROW
    EXECUTE FUNCTION desactivar_lote_sin_stock();

-- ============================================
-- FUNCIÓN FEFO: VENDER PRODUCTO
-- ============================================

-- Esta función implementa la lógica FEFO (First Expired, First Out)
-- Automáticamente selecciona los lotes con vencimiento más cercano
CREATE OR REPLACE FUNCTION fn_vender_producto(
    p_medicamento_id UUID,
    p_cantidad INT,
    p_usuario_id UUID DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_cantidad_restante INT := p_cantidad;
    v_lote RECORD;
    v_cantidad_a_restar INT;
    v_lotes_usados JSON[] := '{}';
    v_total_vendido DECIMAL(10,2) := 0;
BEGIN
    -- Validar que hay stock suficiente
    IF (SELECT COALESCE(SUM(stock_actual), 0) FROM lotes 
        WHERE medicamento_id = p_medicamento_id AND activo = TRUE) < p_cantidad THEN
        RAISE EXCEPTION 'Stock insuficiente. Disponible: %, Solicitado: %', 
            (SELECT COALESCE(SUM(stock_actual), 0) FROM lotes WHERE medicamento_id = p_medicamento_id AND activo = TRUE),
            p_cantidad;
    END IF;

    -- Iterar sobre los lotes ordenados por fecha de vencimiento (FEFO)
    FOR v_lote IN 
        SELECT * FROM lotes 
        WHERE medicamento_id = p_medicamento_id 
        AND activo = TRUE 
        AND stock_actual > 0
        ORDER BY fecha_vencimiento ASC
    LOOP
        -- Calcular cuánto restar de este lote
        v_cantidad_a_restar := LEAST(v_cantidad_restante, v_lote.stock_actual);
        
        -- Actualizar stock del lote
        UPDATE lotes 
        SET stock_actual = stock_actual - v_cantidad_a_restar
        WHERE id = v_lote.id;
        
        -- Registrar movimiento
        INSERT INTO movimientos (
            lote_id, 
            medicamento_id, 
            tipo_movimiento, 
            cantidad, 
            precio_unitario,
            total,
            usuario_id
        ) VALUES (
            v_lote.id,
            p_medicamento_id,
            'VENTA',
            -v_cantidad_a_restar, -- Negativo porque es salida
            v_lote.precio_venta,
            v_lote.precio_venta * v_cantidad_a_restar,
            p_usuario_id
        );
        
        -- Acumular total
        v_total_vendido := v_total_vendido + (v_lote.precio_venta * v_cantidad_a_restar);
        
        -- Guardar información del lote usado
        v_lotes_usados := array_append(
            v_lotes_usados,
            json_build_object(
                'lote_id', v_lote.id,
                'codigo_lote', v_lote.codigo_lote,
                'cantidad', v_cantidad_a_restar,
                'fecha_vencimiento', v_lote.fecha_vencimiento,
                'dias_hasta_vencimiento', v_lote.fecha_vencimiento - CURRENT_DATE
            )
        );
        
        -- Reducir cantidad restante
        v_cantidad_restante := v_cantidad_restante - v_cantidad_a_restar;
        
        -- Si ya completamos la venta, salir del loop
        EXIT WHEN v_cantidad_restante = 0;
    END LOOP;
    
    -- Retornar resumen de la venta
    RETURN json_build_object(
        'success', TRUE,
        'cantidad_vendida', p_cantidad,
        'total', v_total_vendido,
        'lotes_usados', array_to_json(v_lotes_usados)
    );
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- VISTAS CONSOLIDADAS
-- ============================================

-- Vista: Stock total por medicamento (suma de todos los lotes)
CREATE OR REPLACE VIEW vista_stock_total AS
SELECT 
    m.id,
    m.nombre,
    m.principio_activo,
    m.laboratorio,
    c.nombre as categoria,
    m.categoria_id,
    m.stock_minimo,
    COALESCE(SUM(l.stock_actual), 0) as total_disponible,
    MIN(l.fecha_vencimiento) as proximo_vencimiento,
    MIN(l.precio_venta) as precio_venta,
    COUNT(l.id) FILTER (WHERE l.activo = TRUE) as cantidad_lotes_activos,
    -- Semáforo de stock
    CASE 
        WHEN COALESCE(SUM(l.stock_actual), 0) < m.stock_minimo THEN 'BAJO'
        WHEN COALESCE(SUM(l.stock_actual), 0) < m.stock_minimo * 1.5 THEN 'MEDIO'
        ELSE 'ALTO'
    END as estado_stock,
    -- Semáforo de vencimiento
    CASE 
        WHEN MIN(l.fecha_vencimiento) - CURRENT_DATE < 30 THEN 'CRITICO'
        WHEN MIN(l.fecha_vencimiento) - CURRENT_DATE < 90 THEN 'ADVERTENCIA'
        ELSE 'NORMAL'
    END as estado_vencimiento
FROM medicamentos m
LEFT JOIN lotes l ON m.id = l.medicamento_id AND l.activo = TRUE
LEFT JOIN categorias c ON m.categoria_id = c.id
WHERE m.activo = TRUE
GROUP BY m.id, m.nombre, m.principio_activo, m.laboratorio, c.nombre, m.categoria_id, m.stock_minimo;

-- Vista: Productos con stock bajo
CREATE OR REPLACE VIEW vista_stock_bajo AS
SELECT * FROM vista_stock_total
WHERE total_disponible < stock_minimo
ORDER BY total_disponible ASC;

-- Vista: Productos próximos a vencer
CREATE OR REPLACE VIEW vista_proximos_vencer AS
SELECT 
    m.nombre as medicamento,
    l.codigo_lote,
    l.fecha_vencimiento,
    l.fecha_vencimiento - CURRENT_DATE as dias_restantes,
    l.stock_actual,
    CASE 
        WHEN l.fecha_vencimiento - CURRENT_DATE < 30 THEN 'CRITICO'
        WHEN l.fecha_vencimiento - CURRENT_DATE < 90 THEN 'ADVERTENCIA'
        ELSE 'NORMAL'
    END as estado
FROM lotes l
JOIN medicamentos m ON l.medicamento_id = m.id
WHERE l.activo = TRUE 
AND l.stock_actual > 0
AND l.fecha_vencimiento - CURRENT_DATE < 90
ORDER BY l.fecha_vencimiento ASC;

-- ============================================
-- COMENTARIOS EN TABLAS
-- ============================================

COMMENT ON TABLE categorias IS 'Categorías de medicamentos (Analgésicos, Antibióticos, etc.)';
COMMENT ON TABLE medicamentos IS 'Catálogo maestro de medicamentos';
COMMENT ON TABLE lotes IS 'Lotes de medicamentos con fechas de vencimiento (FEFO)';
COMMENT ON TABLE movimientos IS 'Historial de movimientos de inventario (auditoría)';

COMMENT ON COLUMN medicamentos.stock_minimo IS 'Cantidad mínima antes de mostrar alerta';
COMMENT ON COLUMN lotes.codigo_lote IS 'Código del lote impreso en el empaque';
COMMENT ON COLUMN movimientos.cantidad IS 'Positivo para entradas, negativo para salidas';
